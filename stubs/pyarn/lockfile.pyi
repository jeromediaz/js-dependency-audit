from os import PathLike
from typing import List, Dict, Optional, Any, Pattern, TYPE_CHECKING, Mapping

if TYPE_CHECKING:
    import re
    from io import TextIOWrapper

class Package:
    def __init__(
        self,
        name: str,
        version: str,
        url: Optional[str] = None,
        checksum: Optional[str] = None,
        path: Optional[str] = None,
        relpath: Optional[str] = None,
        dependencies: Optional[Dict[str, str]] = None,
        alias: Optional[str] = None,
    ) -> None: ...
    @property
    def relpath(self) -> Optional[str]: ...
    @relpath.setter
    def relpath(self, path: Optional[str]) -> None: ...
    @classmethod
    def from_dict(cls, raw_name: str, data: Dict[str, Any]) -> "Package": ...
    @staticmethod
    def get_path_from_version_specifier(version: str) -> Optional[str]: ...

def _remove_prefix(s: str, prefix: str) -> str: ...
def _must_match(pat: "Pattern", s: str) -> "re.Match": ...

class Lockfile:
    data: Mapping[str, Mapping[str, str]]

    def to_json(self) -> str: ...
    def packages(self) -> List["Package"]: ...
    @classmethod
    def from_file(
        cls, path: int | str | bytes | PathLike[str] | PathLike[bytes]
    ) -> "Lockfile": ...
    @classmethod
    def from_str(cls, lockfile_str: str) -> "Lockfile": ...
    def to_file(
        self, path: int | str | bytes | PathLike[str] | PathLike[bytes]
    ) -> None: ...
    def to_str(self) -> str: ...
    def _dump(self, outfile: "TextIOWrapper") -> None: ...

def _dump_keyval(
    key: str, value: Any, outfile: "TextIOWrapper", indent_level: int
) -> None: ...
def _quote_key_if_needed(key: str) -> str: ...
def _needs_quoting(s: str) -> bool: ...
